#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include "basic_algorithm_linkedList.h"
using namespace std;


/***************文件说明*************
* 文件名：basic_algorithm_linkedList.cpp
* 文件功能：LeetCode初级算法链表部分

**/
/***************函数说明*************
* 函数名：ListNode* removeNthFromEnd(ListNode* head, int n)
* 函数参数：链表的头节点，待删除节点的倒序索引
* 函数返回值：返回节点指针
* 问题描述：
	给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。
	说明：

	给定的 n 保证是有效的。

	进阶：

	你能尝试使用一趟扫描实现吗？
* 解决方案：
		1、两个指针，一个probeNode指针用来遍历链表，直到最后一个节点，另一个preDeleteNode始终与探针保持 n+1 的距离
		2、一旦probeNode和preDeleteNode的距离超过 n+1，两个探针同时移动，否则只移动探针
		3、当探针达到最后尾节点时，preDeleteNode刚好指向待删除节点的前一个节点，删除preDeleteNode的下一个节点（即待删除节点）
		
* 测试信息：
	执行用时 :4 ms, 在所有 cpp 提交中击败了95.49%的用户
	内存消耗 :8.5 MB, 在所有 cpp 提交中击败了88.97%的用户
**/
ListNode* CLinkedList::removeNthFromEnd(ListNode* head, int n)
{
	
	ListNode* probeNode = head;  // 探针，遍历整理表
	ListNode* preDeleteNode = head;  // 待删除的节点的前一个节点
	int distance = 1;
	for (; probeNode->next != NULL; ++distance)
	{

		probeNode = probeNode->next;
		if (distance >= n + 1)  // 如果距离超过 n+1 ，即当探针到达尾指针时，preDeleteNode表示的节点刚好是待删除节点的前一个节点
			preDeleteNode = preDeleteNode->next;

	}
	if (distance == n)  // 退出循环后，distance同时又有整个链表长度的意义，当链表长度等于n时，表示删除头结点
	{  // 因为头结点没有前一个节点，所以要特殊处理
		head = head->next;
		return head;
	}
	preDeleteNode->next = preDeleteNode->next->next;
	return head;

	
}
/***************函数说明***************
* 函数名：
* 函数参数：
* 函数返回值：
* 问题描述：
	反转一个单链表。

	示例:

	输入: 1->2->3->4->5->NULL
	输出: 5->4->3->2->1->NULL
	进阶:
	你可以迭代或递归地反转链表。你能否用两种方法解决这道题？

	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/reverse-linked-list
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
* 解决方案：
	一、迭代（官网）
		在遍历列表时，将当前节点的next指针改为指向前一个元素，由于节点没有引用其上一个节点，因此必须事先先存储其前一个元素。
		在更改引用之前，还需要另一个指针来存储下一个节点，不要忘记在最后返回新的头引用。
	二、迭代（自己复现）
* 测试信息：
	12ms, 67.79%

**/
ListNode* CLinkedList::reverseList(ListNode* head) {
	ListNode* prev = NULL;
	ListNode* curr = head;
	while (curr != NULL)
	{
		ListNode* nextTemp = curr->next;  
		curr->next = prev;
		prev = curr;
		curr = nextTemp;

	}
	return prev;

}

/******************************
* 修改说明：
* 测试信息：
	执行用时 :8 ms, 在所有 cpp 提交中击败了96.00%的用户
	内存消耗 :9 MB, 在所有 cpp 提交中击败了83.31%的用户
**/
ListNode* CLinkedList::reverseList2(ListNode* head) {
	ListNode* tempNode = head;
	ListNode* brigeNode;
	ListNode* reverserHead = NULL;
	while (tempNode != NULL)
	{
		brigeNode = tempNode->next;  // 保留下一个节点的指针
		
		tempNode->next = reverserHead;   // 把这个节点的next指向翻转后链表的头指针

		reverserHead = tempNode;  // 更新头指针

		tempNode = brigeNode;   // 更新用于遍历原链表的指针

		

	}
	return reverserHead;  // 返回头指针
}

// 递归 失败
/*
ListNode* CLinkedList::reverseList3(ListNode* head) {
	
	ListNode* endHead = NULL, * tempNode = NULL;
	ListNode* ansNode;  // 存储返回的节点
	ListNode* nextNode;  // 存储head的下一个节点
	if (head->next != NULL)
	{
		ansNode = reverseList3(head->next);
		ansNode->next = endHead;
		endHead = ansNode;
		head->next = NULL;
	}
	else 
	{
		ListNode* ans = head;
		head = NULL;
		return ans;
	}
	return endHead;

}
*/
ListNode* CLinkedList::reverseList3(ListNode* head) {

	if (head == NULL || head->next == NULL)
		return head;
	ListNode* p = reverseList3(head->next);
	head->next->next = head;
	head->next = NULL;  // 防止链表循环
	return p;

}

/********************函数说明******************
* 函数名：ListNode* mergeTwoLists(ListNode* l1, ListNode* l2)
* 函数参数：两个有序链表
* 函数返回值：两个有序链表合并之后的有序链表
* 函数实现：
*/
// 失败
ListNode* CLinkedList::mergeTwoLists(ListNode* l1, ListNode* l2) {
		
	ListNode *ans;
	ListNode* currNode, *nextNode, *tempNode;
	ListNode* p1 = l1, * p2 = l2;

	while (p1 != NULL && p2 != NULL)
	{
		if (p1->val < p2->val)
		{
			tempNode = p1->next;
			

		}
		if (p1->val >= p2->val)
		{
			
		}



	}
	if (p1 == NULL && p2 != NULL)
	{
		currNode->next = p2;
	}
	else
		currNode->next = p1;

	return currNode->next;


}

/****************函数说明****************
* 函数名：ListNode* getIntersectionNode(ListNode* headA, ListNode* headB)
* 函数参数：两个链表
* 函数返回值：如果两个链表相交，返回两个链表相交的第一个节点，否则返回NULL；
* 函数实现：
	 (一) 两层循环……嘤嘤嘤
	（二）利用路程相等
* 测试信息：5%，两层循环，死慢死慢滴



**/

ListNode* CLinkedList::getIntersectionNode(ListNode* headA, ListNode* headB) {
	ListNode* pA = headA;
	ListNode* pB = headB;
	// 
	if (pA == NULL || pB == NULL)
		return NULL;
	
	while (pA != NULL )
	{
		pB = headB;
		while(pB != NULL)
			if (pA != pB)
			{				
				pB = pB->next;
			}
			else
				return pA;
		pA = pA->next;
	}
	return NULL;
}
ListNode* getIntersectionNode2(ListNode* headA, ListNode* headB)
{
	ListNode* pA = headA;
	ListNode* pB = headB;


	while (pA != pB)
	{
		if (pA == NULL)  // 如果pA走到A链表的尾结点了，转去走B链表
			pA = headB;
		else
			pA = pA->next;

		if (pB == NULL)  // 如果pB走到B链表的尾结点了，转去走A链表
			pB = headA;
		else
			pB = pB->next;

	}
	// 最后相遇的点就是交点
	// A: ――*――
	// B: ―――*―――
	// pA: ――*――  ―――*―――  ―――*―――  ―――*―――  ―――*―――  ―――*―――  ―――*―――  ―――*
	// PB：―――*―――  ――*――  ――*――  ――*――  ――*――  ――*――  ――*――  ――*――  ――*――  ――*（相遇） 
	return pA;
}

/***************函数说明*****************
* 函数名：ListNode* removeElements(ListNode* head, int val)
* 函数参数：链表的头节点，待删除的节点元素值val
* 函数返回值：返回删除所有val值的节点后的新链表
* 函数实现：
	双指针法：
		currNode表示当前节点，preNode表示currNode的前一个节点
		如果当前节点就是要删除的节点，将当前节点的前一个节点指向当前节点的下一个节点（事先定义变量暂存）nextNode，然后把当前节点变为nextNode，继续遍历；
		如果当前节点不是要删除的节点，移动指针。
		这里需要指出的是对头结点是要删除节点的处理
		（一）先处理头结点，再处理其他，保证链表遍历中要删除的点都有前一个节点。
		（二）创建一个虚拟头结点，保证每一个要删除的节点都有一个前驱。
* 测试信息：
	（一） 
		 32ms， 86.37%
	
	（二）执行用时 :32 ms, 在所有 cpp 提交中击败了86.37%的用户
		  内存消耗 :10.9 MB, 在所有 cpp 提交中击败了88.95%的用户
**/
ListNode* CLinkedList::removeElements(ListNode* head, int val) {

	if (head == NULL)
		return NULL;
	while (head != NULL && head->val == val)  // 如果要删除的是头结点（不存在删除节点的前一个节点）
		head = head->next;
	ListNode* preNode = head;  // 存储要删除节点的前一个节点
	ListNode* currNode = head;
	while (currNode != NULL)
	{		
		if ( currNode->val == val)  // 如果现在这个节点就是要删除的节点
		{
			ListNode* nextNode = currNode->next;
			// 虽然这里没有对preNode显式赋值，但是这里可以保证第一次执行的时候先执行的else语句对preNode赋值（因为第一次删除的不可能是头结点，头结点已经在上一条while语句中全部处理掉了）
			preNode->next = nextNode;  // 把当前节点的前一个节点的指针指向当前节点的下一个节点
			currNode = nextNode;  // 继续遍历
		}
		else
		{
			preNode = currNode;
			currNode = currNode->next;
		}
	}
	return head;


}
ListNode* CLinkedList::removeElements2(ListNode* head, int val) {
	
	if (head == NULL)
		return NULL;
	// 创建一个虚拟头结点
	ListNode dummyNode(val - 1);
	dummyNode.next = head;

	ListNode* preNode = &dummyNode;  // 存储要删除节点的前一个节点
	ListNode* currNode = head;
	while (currNode != NULL)
	{
		if (currNode->val == val)  // 如果现在这个节点就是要删除的节点
		{
			ListNode* nextNode = currNode->next;
			
			preNode->next = nextNode;  // 把当前节点的前一个节点的指针指向当前节点的下一个节点
			currNode = nextNode;  // 继续遍历
		}
		else
		{
			preNode = currNode;
			currNode = currNode->next;
		}
	}
	return dummyNode.next;
}
// 16ms， 94.55%
/******************函数说明******************
* 函数名：ListNode* oddEvenList(ListNode* head)
* 函数参数：一个链表
* 函数返回值：返回一个将原链表的奇数节点和偶数节点重新排列后的链表
* 问题描述：
	给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。

	请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。

	来源：力扣（LeetCode）
	链接：https://leetcode-cn.com/problems/odd-even-linked-list
	著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

* 解决方案：
		五个变量，分别表示当前奇数节点、当前偶数节点、下一个奇数节点、下一个偶数节点、偶数节点的起始节点
		1、更改指向关系
			将当前奇数节点的下一个节点变为下一个奇数节点：oddNode->next = nextOdd;
			将当前偶数节点的下一个节点变为下一个偶数节点：evenNode->next = nextEven;
			建立奇偶连接，让新的奇数节点的下一个节点是偶数节点的起始节点：nextOdd->next = evenBegin;
		2、更新节点：
			将当前奇数节点变为下一个奇数节点：oddNode = nextOdd;
			当前偶数节点变为下一个偶数节点：evenNode = nextEven;
**/
ListNode* oddEvenList(ListNode* head) {
	

	if (head == NULL || head->next == NULL)
		return head;
	ListNode* oddNode = head, * evenNode = head->next;  // 分别表示当前的奇数节点和偶数节点
	ListNode* nextOdd, * nextEven;  // 分别表示下一个奇数节点和偶数节点
	ListNode* evenBegin = head->next;
	// 不管是奇数还是偶数，只要退出循环就可以返回了
	while (evenNode != NULL && evenNode->next != NULL)
	{
		nextOdd = evenNode->next;  // 保存节点
		nextEven = nextOdd->next;

		oddNode->next = nextOdd;  // 更改指向关系
		evenNode->next = nextEven;

		nextOdd->next = evenBegin;  // 建立奇偶连接

		// 更新节点
		oddNode = nextOdd;
		evenNode = nextEven;
	}
	// 如果 evenNode == NULL，说明当前的偶数节点就是最后一个节点（NULL）
	// 如果 evenNode->next == NULL，说明当前的偶数节点就是尾结点，尾结点后面是NULL
	return head;
}

bool isPalindrome(ListNode* head) {
	
	
	ListNode* currNode = head;
	ListNode* preNode = head;
	
	while (currNode != NULL && head != NULL)
	{
		preNode = currNode;
		
		
		if (currNode->next == NULL)  // 此时当前节点是尾结点
		{
			if (currNode->val == head->val)  // 如果是回文链表，尾结点的值等于头结点的值
			{
				head = head->next;				
				currNode = preNode;
			}
			else
				return 0;
		}
		else
		{
			currNode = currNode->next;
		}
	}
}

